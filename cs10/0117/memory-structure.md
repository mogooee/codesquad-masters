# 프로세스 메모리 구조 모델

![](https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/16403278811501%2AfwkyPI8Gmzd0Q_XAGM5_eA.png)
<br>
<br>

## 메모리 구조란?

운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공한다.
프로그램이 운영체제로부터 할당 받는 대표적인 메모리 공간을 메모리 구조라 한다.
<br>
<br>

## 스택(Stack)

함수 인자 값, 함수 내의 지역 변수, 매개변수와 함수의 반환 주소 등이 임시로 저장되는 영역으로 함수 호출의 전반적인 처리와 리턴 값을 가지고 있다. 이 영역에 할당된 변수들은 함수 호출이 완료되면 소멸한다. 가장 마지막에 삽입된 원소가 제일 먼저 삭제되는 후입선출(LIFO)방식으로 처리되며 스택에 적재되면 상위 메모리 주소(큰 주소값)에서 하위 메모리 주소(적은 주소값)로 데이터가 저장된다.

- 장점: 낭비되는 공간이 없다, 하나의 명령만으로 메모리 조작과 어드레스 조작이 가능하다.
- 단점: 한계가 있어 초과하도록 삽입할 수 없다, 유연성이 부족하다.
  <br>
  <br>

## 힙(Heap)

- 프로그래머의 필요에 따라 동적 메모리 호출에 의해 할당되는 메모리 영역이다.

  _?동적 할당? 런타임때 메모리를 할당 받는 것_
  c언어 기준으로 malloc() 함수나 calloc() 함수에 의해 생성된 변수들이 이 곳에 할당된다. 복합 자료형을 저장하는 메모리 공간
  힙영역은 메모리의 낮은 주소(처음 주소 값 기준)에서 높은 주소의 방향으로 할당된다.

- 장점: 프로그램에 필요한 개체의 개수나 크기를 미리 알 수 없는 경우에 사용 가능, 개체가 너무 커서 스택 할당자에 맞지 않는 경우 사용가능
- 단점: 할당 작업으로 인한 속도 저하, 해제 작업으로 인한 속도 저하

- 힙을 사용하는 이유

1. Life Cycle

   스택은 Life Cycle이 함수 실행이 끝나면 변수가 모두 소멸되므로, 힙에다가 데이터를 넣고, 스택에서 포인터변수가 이를 가리키게 하면 저장할 수 있다.

2. 메모리 용량

   스택에 포인터 변수로 힙의 메모리 주소를 가리키게 하면 힙에 아주 큰 메모리 데이터를 관리할 수 있다.
   <br>
   <br>

## 스택 vs 힙

1. 메모리 해제

   스택과 힙의 큰 차이점은 메모리 해제다. 스택에 생성된 변수는 사용한 뒤 따로 처리를 해주지 않아도 되지만 malloc 함수를 사용하여 힙에서 할당한 메모리는 free함수로 반드시 해제를 해주어야 한다. 메모리를 할당만 하고 해제를 해주지 않으면 결국에는 시스템의 메모리가 부족해지므로 운영체제가 프로그램을 강제로 종료시키거나 메모리 할당에 실패하게 된다. 메모리를 해제하지 않아 메모리 사용량이 계속 증가하는 현상을 메모리 누수(memory leak)라 부른다.

2. BufferOverFlow

   스택은 상위 메모리 주소에서 하위 메모리 주소로, 힙은 처음 주소 값을 기준으로 점차 큰 주소 값으로 저장된다. 이러한 차이를 갖는 가장 큰 이유는 BufferOverFlow를 막기 위해서이다.

   예전에는 스택 영역이 초과되는 크기의 데이터를 저장하여 커널 영역에 침범해 데이터를 조작하여 관리자 권한을 해킹했었다. 이러한 이유로 스택은 상위 메모리 주소부터 적재된다.

   Stack 영역의 데이터가 넘쳐 Heap 영역을 침범하면 Stack Overflow
   주로 자기 자신을 호출하는 '재귀 호출'로 인해 발생한다.

   Heap 영역의 데이터가 넘쳐 Stack 영역을 침범하면 Heap Overflow
   앞에 언급했던 사용자가 직접 메모리를 소멸시키지 않는 경우, 메모리 누수가 있을 경우 발생한다.

3. 스택은 컴파일시 이미 할당되어 있는 공간을 사용하는 것이고 힙은 런타임시 사용자가 따로 동적으로 할당해서 사용하는 공간이다. 컴파일 시에 알 수 있는 정보들을 스택에 포인터 변수를 두므로 프로그램 실행과정에서 dynamic하게 동적할당으로 힙 메모리에서 저장할 수 있다.

4. 속도는 스택이 빠르지만 공간이 매우 작아서 모든 응용에서 스택을 사용할 수는 없다.

5. JS에서 stack은 원시타입인 불변성 데이터가 저장되는 곳이고 heap은 나머지 참조형 데이터 타입인 가변성 데이터가 저장되는 곳이다. 즉, 숫자, 문자열, 불리언, 심볼, Null, Undefiend는 stack에 저장되고 원시 값을 제외한 나머지 데이터 타입인 객체, 배열, 함수 등은 heap에 저장된다.
   -> 불변성인 원시 값은 변수에 다른 값을 할당했을 때 변수가 가리키는 메모리 주소가 달라지고 가변성인 데이터 타입인 변수에 값을 추가, 삭제하면 힙영역의 값이 변경된다.
   <br>
   <br>

## 텍스트(코드 영역)

사용자가 작성한 프로그램 코드와 상수가 정의되어있고, 읽기만 가능한 메모리 영역이다. 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간이다.
<br>
<br>

## 글로벌변수(데이터 영역)

프로그램의 전역 변수, 상수, 정적(static) 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
<br>
<br>

## Garbage Collection

JS에서는 가비지 컬렉션이라는 자동 메모리 관리 형식을 활용한다. 가비지 콜렉터의 목적은 메모리 할당을 모니터링 하고 할당된 메모리 블록이 더 이상 필요하지 않은 시점을 확인하여 힙 영역에 할당된 메모리를 정리, 회수하는 것이다.
<br>
<br>
<br>
<br>

# 리눅스 커널의 가상메모리

- 커널이 메모리를 관리한다.
- 리눅스는 하나의 태스크에 4GB 크기의 가상 메모리 주소 공간을 할당
- 태스크의 가상 메모리 공간에 있는 페이지들 가운데 현재 수행에 필요한 부분만 물리 메모리에 올려 수행, 물리 메모리가 부족해지면 일정 부분의 페이지들을 다시 하드디스크로 이동
  => 물리 메모리의 한계를 극복하기 위해 가상메모리, 페이징 기법(가상주소->물리주소) 등을 적용

- 물리 주소: 시스템에 장착된 물리적인 메모리의 직접적인 위치 주소
- 가상 주소: 물리 주소와 상관없이 각 태스크마다 할당하는 논리적인 주소로 CPU가 생성하는 주소다.
- 페이지: 가상 메모리를 일정한 고정 크기로 분할하는 단위(4kb)
- 가상 메모리: 가상 메모리는 메모리를 관리하는 방법의 하나로, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 말한다. 가상 메모리를 이용하면 실제 물리메모리가 가지고 있는 크기를 논리적으로 확장하여 사용 할 수 있다.

- 가상메모리를 사용하는 이유

1. 논리적으로 메모리를 확장하여 사용할 수 있다.
2. 프로세스들에게 동일한 메모리 공간을 제공해 줄 수 있다.
3. 메모리 관리에 효율적이다. - 논리적으로 연속적인 메모리 형태로 사용가능하다.
   <br>
   <br>
   <br>
   <br>

# 자바스크립트의 가상메모리 관리, 가비지 콜렉션(GC) 동작 방식

## 자바스크립트의 가상메모리 관리

c언어같은 *low level*언어에서는 메모리 관리를 위해 malloc()과 free()를 사용한다.  
반면, 자바스크립트는 객체와 원시값을 제외한 데이터들이 생성되었을 때 자동으로 메모리를 할당하고 쓸모 없어졌을 때 자동으로 해제한다.(가비지 컬렉션) 이러한 자동 메모리 관리는 잠재적 혼란의 원인이기도 한데, 개발자가 메모리 관리에 대해 고민할 필요가 없다는 잘못된 인상을 줄 수 있기 때문이다.
<br>
<br>

## 메모리 생존주기

모든 프로그래밍 언어는 비슷한 메모리 생존주기를 갖는다.

1. 필요할때 할당한다.
2. 사용한다. (읽기, 쓰기)
3. 필요없어지면 해제한다.

두 번째 부분은 모든 언어에서 명시적으로 사용된다. 그러나 첫 번째 부분과 마지막 부분은 저수준 언어에서는 명시적이며, 자바스크립트와 같은 대부분의 high level 언어에서는 암묵적으로 작동한다.
<br>
<br>

## 가비지 콜렉션(GC)

가비지 콜렉션 알고리즘의 핵심 개념은 **참조**이다. A라는 메모리를 통해 (명시적이든 암시적이든) B라는 메모리에 접근할 수 있다면 "B는 A에 참조된다" 라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 prototype 을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.

"더 이상 필요없는 오브젝트"를 "어떤 다른 오브젝트도 참조하지 않는 오브젝트"라고 정의한다. 이 오브젝트를 "가비지"라 부르며, 이를 참조하는 다른 오브젝트가 하나도 없는 경우, 수집이 가능하다.

<br>
<br>
<br>

> [ Reference ]
>
> - [메모리구조 스택(Stack)과 (Heap)의 차이점](https://akdl911215.tistory.com/338)
> - [C++/ C언어의 메모리 구조: 데이터(Data), 스택(Stack) 그리고 힙(Heap) 영역](https://bskyvision.com/160)
> - [[C언어/C++] 구조체, 클래스의 패딩 바이트에 대하여](https://coding-factory.tistory.com/670)
> - [자바스크립트의 메모리 관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)
> - [[LInux Kernel] 메모리 관리 : 가상 메모리 ](https://wogh8732.tistory.com/395)
> - [Linux System & Kernel: 운영체제 리눅스 메모리 관리와 페이징](https://seven00.tistory.com/entry/Linux-System-Kernel-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%95)
